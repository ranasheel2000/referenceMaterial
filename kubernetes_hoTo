**************************************************************************************************************
************************               SINGLE NODE SETUP(MINIKUBE)                    ************************
**************************************************************************************************************

Install VirtualBox on linux(Ubuntu)
==================================
sudo apt-get update
sudo apt-get upgrade

wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -

sudo add-apt-repository "deb http://download.virtualbox.org/virtualbox/debian `lsb_release -cs` contrib"

sudo apt-get update
sudo apt-get install virtualbox-5.2

Install KubeCtl
================
sudo apt-get update && sudo apt-get install -y apt-transport-https
sudo apt install curl
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
sudo touch /etc/apt/sources.list.d/kubernetes.list 
echo "deb http://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
sudo apt-get update
sudo apt-get install -y kubectl

Installing minikube
====================
curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.28.2/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/
chmod +x minikube 
sudo mv minikube /usr/local/bin/

=============================================
kubernetes on single node with virtualbox
=============================================
sudo apt install docker.io

curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube
chmod +x minikube 
sudo mv minikube /usr/local/bin/

curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl && chmod +x kubectl

export MINIKUBE_WANTUPDATENOTIFICATION=false
export MINIKUBE_WANTREPORTERRORPROMPT=false
export MINIKUBE_HOME=$HOME
export CHANGE_MINIKUBE_NONE_USER=true
mkdir -p $HOME/.kube
touch $HOME/.kube/config

export KUBECONFIG=$HOME/.kube/config
sudo -E /usr/local/bin/minikube start --vm-driver=none

# waits until kubectl can access the api server that Minikube has created
for i in {1..150}; do # timeout for 5 minutes
   kubectl get po &> /dev/null
   if [ $? -ne 1 ]; then
      break
  fi
  sleep 2
done

# kubectl commands are now able to interact with Minikube 


Installing Go
================
- downlaod golang: 
             https://golang.org/dl/

- copy downloaded golang repo to /usr/local/
- set GOROOT: 
             GOROOT is go installation directory i.e. /usr/local/go/bin/
             export PATH=$PATH:/usr/local/go/bin
- set GOPATH : 
             GOPATH is environment variable which specifies the location of your workspace(working directory) 
             i.e. directory where go code is stored. 
             It defaults to a directory named go inside your home directory, so $HOME/go on Unix
             cd $HOME   (ex, /home/sheel)
             mkdir go
             export GOPATH=$HOME/go

***********************************************************************************************************************
*********************************       Kubernetes resource create            *****************************************
***********************************************************************************************************************

Create a pod for a container:
===========================

apiVersion: v1
kind: Pod
metadata:
  name: sheel-pod
  labels:
    zone: prod
    version: v1
    name: sheel-pod
spec:
  containers:
  - name: sheel-ctr
    image: myimage:v0.5
    command: ["sh", "-c", "tail -f /dev/null"]
    ports:
    - containerPort: 5000
      name: http
      protocol: TCP 


Expose a pod:
=============
kubectl expose pod sheel-pod --type=NodePort --port=8080
kubectl expose deployment sheel-depolyment-1 --port=8080 --target-port=

Ingress rule:   Ingress rule routes user request to specific service.
=============
                
1.)Name-Based Virtual Hosting Ingress rule:
   ----------------------------------------
    Following ingress rule specify the route;
                - if user makes request for ranasheel2000.github.com, ingress rule will routes request to svc-1 service.
                - if user makes request for kubernetes.github.com, ingress will routes request to svc-2 service.
ingress.yaml
------------
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: web-ingress
  namespace: default
spec:
  rules:
  - host: ranasheeel2000.github.com
    http:
      paths:
      - backend:
          serviceName: svc-1
          servicePort: 80
  - host: kubernetes.github.com
    http:
      paths:
      - backend:
          serviceName: svc-2
          servicePort: 80
2.) Fan Out Ingress rule:
     In this rule, we can specify the doamin name and can route requests according to preeceeding url.
     For ex, github.com/ranasheel2000 and github.com/kubernetes
                - if user makes request for github.com/ranasheel2000, ingress rule will routes request to svc-1 service.
                - if user makes request for github.com/kubernetes, ingress will routes request to svc-2 service.
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: web-ingress
  namespace: default
spec:
  rules:
  - host: github.com/ranasheel2000
    http:
      paths:
      - backend:
          serviceName: svc-1
          servicePort: 80
  - host: github.com/kubernetes
    http:
      paths:
      - backend:
          serviceName: svc-2
          servicePort: 80


Ingress controller: is used for request forwarding from ingress endpoint to service. 
==================
                   It is an application which watches Master Node's API server for changes in the Ingress resources(Ingress rules) and 
                   updates the Layer 7 Load Balancer accordingly.

Steps to deploy Ingress and access service through Ingress:
=================================================
    1. Deploy Ingress Controller with Minikube
          minikube addons enable ingress
    2. create Ingress Resource: This is done after deploying ingress controller.
          kubectl create -f ingress.yaml

    3. update /etc/hosts, map minikubeIP and URLs to access ser-1 and ser-2.
       We are mapping it to minikubeIP as ingress rules will be created within minikube scope.
          127.0.0.1     localhost.undercloud
          ::1           localhost.undercloud
          {minikube IP} github.com/ranasheel2000 github.com/kubernetes 
    4. List ingress rules:    
          kubectl describe ingress {name-of-ingress-resource}
    
    
Application can be deployed usig [Deployments, Services, Volume Claims, Ingress] etc

Controllers:  A controller uses apiserver to watch the shared state of the cluster and
===========       makes corrective changes to the current state to change it to the desired one.
Ex of different controllers is:
    1. endpoint controller : takes care of the endpoint and their availibility.
    2. namespace controller : 
    3. service account controller : takes care of the services and their desired state.
    4. Replication controller  : takes care of the number of PODs in the kubernetes system.
   
kubectl       -> CLI which manages the PODs etc using API Server.
Controller    -> watches state of cluster using API Server. 
kubelet       -> kubelet is an agent for managing the node and communicating with the Kubernetes master. 
                 It gets pod configuration from apiserver, ensures described containers are up and running.
kubeproxy     -> is a network proxy and load balancer for a service on a single worker node.
                 It takes care of the network routing for TCP and UDP packets.
                 communicates with etcd, to get information about services and write the details about newly created ones.


Basic docker commands:
======================
docker images
docker pull {docker-image name like ngnix}
docker run {container-name}
docker exec -it {container-name} /bin/bash
ctrl+d to run out of container entered through "docker exec -it"



kubectl commands:
=================
  create         Create a resource from a file or from stdin.
  expose         Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service

  set            Set specific features on objects
  get            Display one or many resources
       kubectl get pod {name-of-pod}
       kubectl get deployment {name-of-deployment}
       kubectl get service {name-of-service
       kubectl get nodes :It will list all nodes/VMs running which are ok to accept any deployments.
           
  explain        Documentation of resources
  edit           Edit a resource on the server
  delete         Delete resources by filenames, stdin, resources and names, or
by resources and label selector

Deploy Commands:
  run            Run a particular image on the cluster
      kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080
      
  run-container  Run a particular image on the cluster. This command is deprecated, use "run" instead
  rollout        Manage the rollout of a resource
  rolling-update Perform a rolling update of the given ReplicationController
  scale          Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job
  autoscale      Auto-scale a Deployment, ReplicaSet, or ReplicationController

Cluster Management Commands:
  certificate    Modify certificate resources.
  cluster-info   Display cluster info
  top            Display Resource (CPU/Memory/Storage) usage.
  cordon         Mark node as unschedulable
  uncordon       Mark node as schedulable
  drain          Drain node in preparation for maintenance
  taint          Update the taints on one or more nodes
  
Troubleshooting and Debugging Commands:
  describe       Show details of a specific resource or group of resources
  logs           Print the logs for a container in a pod
  attach         Attach to a running container
  exec           Execute a command in a container
  port-forward   Forward one or more local ports to a pod
  proxy          Run a proxy to the Kubernetes API server
  cp             Copy files and directories to and from containers.
  auth           Inspect authorization

Advanced Commands:
  apply          Apply a configuration to a resource by filename or stdin
  patch          Update field(s) of a resource using strategic merge patch
  replace        Replace a resource by filename or stdin
  convert        Convert config files between different API versions
  
Settings Commands:
  label          Update the labels on a resource
  annotate       Update the annotations on a resource
  completion     Output shell completion code for the specified shell (bash or
zsh)

Other Commands:
  api-versions   Print the supported API versions on the server, in the form of "group/version"
  config         Modify kubeconfig files
  help           Help about any command
  plugin         Runs a command-line plugin
  version        Print the client and server version information
  


